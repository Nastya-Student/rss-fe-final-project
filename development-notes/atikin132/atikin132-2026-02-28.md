# Дата: 2026-02-28

  

## Что было сделано

Сегодня поправлял [Pull Request](https://github.com/Nastya-Student/rss-fe-final-project/pull/16). Решили, что всё-таки лучше вынести похожий код отдельно в родительский класс. После это команда одобрила [Pull Request](https://github.com/Nastya-Student/rss-fe-final-project/pull/16), я его замержил в `develop`, а потом из `develop` замержил в свою ветку с `dashboard`, в этот раз обошлось без конфиктов.

Убрал наконец-то из метода `create` в классе `DashboardPage` массивы с данными, которых там быть не должно, и заменил их на работу с сервисами, создал метод `initDashboardElements()`, в котором уже инициализируются все элементы:
```typescript
private  async  initDashboardElements():  Promise<void> {
  this.user  =  await  userService.getUserById(this.USER_ID);
  if (this.user  ===  undefined) {
    return;
  }
  this.userGreeting.textContent  =  `Hello, ${this.user.name}!`;
  
  this.userTopicArr  = (await  topicProgressService.getTopicProgressByUserId(this.user.id)) ?? [];
  if (this.userTopicArr  ===  undefined) {
    return;
  }

  this.progressContainer.innerHTML  =  "";
  const { topicsProgressContainer, streakContainer } =  progressComponent(this.user,this.userTopicArr,);
  this.progressContainer.append(topicsProgressContainer);
  this.progressContainer.append(streakContainer);

  this.userSessionArr  = (await  practiceSessionService.getPracticeSessionsByUserId(this.user.id,)) ?? [];
  if (this.userSessionArr  ===  undefined) {
    return;
  }
  this.userSessionArr.sort((a, b) => {
    return (new  Date(b.completedAt).getTime() -  new  Date(a.completedAt).getTime());
  });

  this.renderSessions();
}
```
 И вызываю его в конце метода `create` вот так:
```typescript
this.initDashboardElements().catch(() => {
  throw  new  Error("Error loading dashboard");
});
```
Наверное вместо вызова исключения можно будет добавить какое-нибудь уведомление для пользователя.

## Проблемы

Возникла проблема со вложенностью `dashboard__progress-container`, потому что функция `progressComponent` принимает пользователя, и массив с темами, которые он проходил и возвращает контейнер с классом `dashboard__progress-container`, но так как на момент выполнения метода `create` пользователя ещё нет, то я создал пустой контейнер с классом `dashboard__progress-container`, а потом уже в `initDashboardElements()` добавлял в этот контейнер еще один, потому что функция `progressComponent` его возвращала.

  
## Решения (или попытки)

В итоге решил использовать тот же поход, что и с `sessionHistoryComponent`: возвращать из функции `progressComponent` объект такого вида: `{ topicsProgressContainer:  HTMLElement; streakContainer:  HTMLElement;}`, и не создавать для них контейнера в этой функции, а создать контейнер в методе `create`, а в `initDashboardElements()` уже вызвать функцию `progressComponent`, и добавлять в контейнер `dashboard__progress-container` оба этих контейнера через `append()`


## Мысли / Планы

Так как Ульяна пока исправляет комментарии Насти, то пока не могу адаптировать свой dashboard под Ульянин дизайн.
Думаю завтра уже браться за какой-нибудь виджет.
  

### Затраченное время: 1,5 часа
